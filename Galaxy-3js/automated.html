<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exoplanetary System Visualization</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chivo+Mono:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; 
            overflow: hidden;
            font-family: "Chivo Mono", monospace;
            font-optical-sizing: auto;
            font-weight: 500;
            font-style: normal; }
        #search-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
        }
        #search-bar input {
            padding: 5px;
            font-size: 16px;
        }
        #planet-info { 
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
        }
        .heading {
            font-size: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="search-bar">
        <label for="hostNameInput">Host Star Name:</label>
        <input type="text" id="hostNameInput" placeholder="Enter host star name">
    </div>
    <div id="planet-info">
        <div class="heading">Exoplanetary System</div>
        <p>Enter a host star name to see its planetary system.</p>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        const textureLoader = new THREE.TextureLoader();
        const backgroundTexture = textureLoader.load('assets/milkyway.jpg');

        // Create a large sphere for the background
        const backgroundGeometry = new THREE.SphereGeometry(500, 64, 64);
        const backgroundMaterial = new THREE.MeshBasicMaterial({ 
            map: backgroundTexture, 
            side: THREE.BackSide 
        });
        const backgroundSphere = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
        scene.add(backgroundSphere);

        const light = new THREE.PointLight(0xffffff, 1, 1000);
        light.position.set(0, 0, 0);
        scene.add(light);

        let planetarySystems = new Map(); // Map to hold planetary systems data
        let planets = [];
        let orbits = [];
        let planetSpeeds = [];
        let currentStar = null;
        // Function to load random planet textures
        function getRandomTexture(folderPath) {
            const textures = [
                `${folderPath}/planet1.png`,
                `${folderPath}/planet2.png`,
                `${folderPath}/planet3.png`,
                `${folderPath}/planet4.png`,
                `${folderPath}/planet5.png`,
                `${folderPath}/planet6.png`,
                `${folderPath}/planet7.png`,
            ];
            return textures[Math.floor(Math.random() * textures.length)];
        }

        function setupSystem(systemData) {
    planetSpeeds = [];
    console.log(systemData)
    
    // Remove previous star and planets from the scene
    if (currentStar) {
        scene.remove(currentStar);
        currentStar.geometry.dispose();
        currentStar.material.dispose();
        currentStar = null;
    }
    
    planets.forEach(p => {
        scene.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
    });
    orbits.forEach(p => {
        scene.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
    });
    planets = [];
    orbits = [];
    planetSpeeds = [0.01];

    // Create star (the central "Sun")
    const starTexture = textureLoader.load('assets/stars/star1.jpg');
    const starGeometry = new THREE.SphereGeometry(systemData[0].star_radius * 4, 32, 32);
    const starMaterial = new THREE.MeshBasicMaterial({ map: starTexture });
    currentStar = new THREE.Mesh(starGeometry, starMaterial);
    currentStar.name = systemData[0].star_name;
    scene.add(currentStar);

    // Create planets
    systemData.forEach((planetData, index) => {
        // Calculate the distance from the star using star radius
        const distance = (systemData[0].star_radius * 10) + (index + 1) * 10; // Adjust scaling factor as necessary
        createPlanet(planetData, distance, planetData.planet_name);
        planetSpeeds.push(planetSpeeds[planetSpeeds.length - 1] / 2);
    });
    console.log(planetSpeeds);
}

    function createPlanet(planetData, distance, planetName) {
        let temp = planetData.planet_temperature != null ? planetData.planet_temperature : 
                calculatePlanetTemperature(planetData.star_temperature, planetData.star_mass, planetData.star_radius, planetData.orbital_period);
        
        const type = classifyPlanetByTemperature(temp);
        const radius = planetData.planet_radius; // Planet radius to be used as is
        const usedTextures = new Set();

        const availableTextures = planetTextures[type].filter(texture => !usedTextures.has(texture));
        const randomIndex = Math.floor(Math.random() * availableTextures.length);
        const selectedTexture = availableTextures[randomIndex];

        const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
        const planetTexture = textureLoader.load(selectedTexture);
        const material = new THREE.MeshStandardMaterial({ map: planetTexture });
        const planet = new THREE.Mesh(planetGeometry, material);
        planet.position.x = distance; // Set the planet's distance from the star
        planet.name = planetName; 

        scene.add(planet);
        usedTextures.add(selectedTexture); // Mark this texture as used
        planets.push({ mesh: planet, distance, angle: 0 });

        const orbitGeometry = new THREE.RingGeometry(distance - 0.1, distance + 0.1, 64); 
        const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
        orbit.rotation.x = Math.PI / 2;
        scene.add(orbit);
        orbits.push({ mesh: orbit, distance, angle: 0 });
    }


        // Global variables
        const planetTextures = {
            hot: [],
            earth_like: [],
            icy: []
        };

        // Function to load textures from folders
        function loadPlanetTextures() {
            const types = ['hot', 'earth_like', 'icy'];
            types.forEach(type => {
                for (let i = 1; i <= 7; i++) {
                    const texturePath = `assets/${type}/planet${i}.png`;
                    planetTextures[type].push(texturePath);
                }
            });
        }
        loadPlanetTextures();

        // Function to classify the planet based on temperature
        function classifyPlanetByTemperature(temperature) {
            if (temperature > 310) {
                return 'hot';
            } else if (temperature > 200 && temperature <= 310) {
                return 'earth_like';
            } else {
                return 'icy';
            }
        }


        function calculatePlanetTemperature(starTemperature, starMassSolar, starRadiusSolar, orbitalPeriodDays, albedo = 0.3) {
            const G = 6.67430e-11;  // Gravitational constant in m^3 kg^-1 s^-2
            const solarMassKg = 1.989e30;  // Mass of the Sun in kg
            const solarRadiusM = 6.96e8;  // Radius of the Sun in meters

            // Convert star mass and radius to SI units (kg and meters)
            const starMassKg = starMassSolar * solarMassKg;
            const starRadiusM = starRadiusSolar * solarRadiusM;

            // Convert orbital period to seconds
            const orbitalPeriodSeconds = orbitalPeriodDays * 86400;

            // Kepler's 3rd law to find the semi-major axis 'a'
            const aCubed = (G * starMassKg * Math.pow(orbitalPeriodSeconds, 2)) / (4 * Math.pow(Math.PI, 2));
            const semiMajorAxis = Math.pow(aCubed, 1 / 3);

            // Calculate the planet temperature using the equilibrium temperature formula
            const planetTemperature = starTemperature * Math.sqrt(starRadiusM / (2 * semiMajorAxis)) * Math.pow((1 - albedo), 0.25);

            return planetTemperature;
        }

        // Display planet information
        function displayPlanetInfo(systemData) {
            const infoDiv = document.getElementById('planet-info');
            const heading = document.querySelector('.heading');
            let starName = systemData[0].star_name;
            console.log(starName)
            heading.textContent = `System: ${starName} system`;

            let content = `<strong>Star Name:</strong> ${starName}<br>`;
            systemData.forEach(planetData => {
                content += `<strong>Planet Name:</strong> ${planetData.planet_name}<br>
                <strong>Planet Radius:</strong> ${planetData.planet_radius} Earth radii<br>
                <strong>Planet Mass:</strong> ${planetData.planet_mass} Earth masses<br>
                <strong>Star Temperature:</strong> ${planetData.star_temperature} K<br>
                <strong>Star Radius:</strong> ${planetData.star_radius} Solar radii<br><br>`;
            });

            infoDiv.innerHTML = content;
        }

        // Fetch and load exoplanetary data
        async function fetchSystemData() {
            try {
                const response = await fetch('planets.json');
                const data = await response.json();
                
                // Organize the data into the map
                data.forEach(system => {
                    if (!planetarySystems.has(system.star_name)) {
                        planetarySystems.set(system.star_name, []);
                    }
                    planetarySystems.get(system.star_name).push(system);
                });

                console.log(planetarySystems); // For debugging
            } catch (error) {
                console.error('Error fetching system data:', error);
            }
        }

        fetchSystemData();

        // Input event listener for searching a planetary system by host star name
        const input = document.getElementById('hostNameInput');
        input.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                const hostName = input.value.trim();
                if (planetarySystems.has(hostName)) {
                    const systemData = planetarySystems.get(hostName);
                    setupSystem(systemData);
                    displayPlanetInfo(systemData);
                } else {
                    alert('System not found.');
                }
            }
        });

        // Orbiting animation
        function animate() {
            requestAnimationFrame(animate);
            planets.forEach((planet, index) => {
                planet.angle += planetSpeeds[index];
                planet.mesh.position.x = Math.cos(planet.angle) * planet.distance;
                planet.mesh.position.z = Math.sin(planet.angle) * planet.distance;
            });
            controls.update();
            renderer.render(scene, camera);
        }

        camera.position.z = 100;
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
